关于一条查询语句在mysql中的执行流程
对应图片1.png

如 select name from test where id=2

1.连接器---先与mysql服务端连接器建立连接，若查询缓存命中则直接返回
（查询缓存的弊端：查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。）

2.分析器---词法分析告诉服务端你要干什么（我要找 test表中id为2的名字）
(其中sql语法错误在这块暴露)

3.优化器---服务端会思考该怎么执行最优(索引的选择)

4.执行器---检查用户对库对表的权限

5.存储引擎--存储数据，提供读写接口

##补充：关于一条更新语句在mysql中的流程
update a set name=1 where id=1;
除了上面几个环节，再查到数据之后，如果是innodb引擎它会进行日志的两阶段提交(先写日志再写磁盘)
1.写入redolog日志，处于prepare阶段
2.写入binlog日志，此时提交事务，处于commit
即要么都成功，要么都失败!!

redolog和binlog的区别:
redolog是物理日志，循环写，记录了某个数据页上做了什么修改,是innodb独有的
binlog是逻辑日志，追加写，记录了一条mysql的原始逻辑 即原始语句

redo log 用于保证 crash-safe 能力。**innodb_flush_log_at_trx_commit** 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。**sync_binlog** 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。

**关于change buffer**
另外innodb是按数据页从磁盘读取数据到内存中的，当要更新数据时，
如果数据页中则直接更新，
不在呢？不是从磁盘读取数据，而是将这个更新操作**缓存在change buffer中**（redo log也会记录这个change buffer操作）
等到下一次查询要用到这些记录时再执行这些操作（成为merge）
**change buffer里面的内容会因为重启丢失吗**
不会，它在内存中有拷贝，也会被写入到磁盘中，数据库正常关闭也会触发merge操作
但是它的使用也是有条件的




##补充：执行器的执行逻辑
比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：
1.调用 InnoDB 引擎接口取这个表的**第一行**，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；
2.调用引擎接口取“下一行”，重复相同的判断逻辑，**直到取到这个表的最后一行**。
3.执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。至此，这个语句就执行完成了。
也就是说没有索引的话，会进行**全表扫描**
慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

